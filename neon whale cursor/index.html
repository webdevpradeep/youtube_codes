<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Neon Whale Cursor â€” Underwater @inflection org</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="whale"></div>

    <!-- layered visual elements for realistic water -->
    <div class="light-shafts" aria-hidden="true"></div>
    <div class="water-distort" aria-hidden="true"></div>
    <div class="seabed-vignette" aria-hidden="true"></div>

    <!-- SVG overlay for subtle animated caustics (uses feTurbulence for organic movement) -->
    <svg
      id="causticsSVG"
      style="
        position: fixed;
        inset: 0;
        pointer-events: none;
        mix-blend-mode: overlay;
        opacity: 0.18;
      "
      width="100%"
      height="100%"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
    >
      <defs>
        <filter id="turb" x="0%" y="0%" width="100%" height="100%">
          <feTurbulence
            baseFrequency="0.8"
            numOctaves="2"
            seed="2"
            stitchTiles="stitch"
            result="noise"
          />
          <feColorMatrix type="saturate" values="0.2" />
          <feGaussianBlur stdDeviation="3" result="blurred" />
          <feBlend in="SourceGraphic" in2="blurred" mode="overlay" />
        </filter>
        <linearGradient id="causticGradient" x1="0" x2="1">
          <stop offset="0" stop-color="#aef1ff" stop-opacity="0.25" />
          <stop offset="1" stop-color="#6fdcff" stop-opacity="0.05" />
        </linearGradient>
      </defs>
      <rect
        width="100%"
        height="100%"
        fill="url(#causticGradient)"
        filter="url(#turb)"
      ></rect>
    </svg>

    <!-- include original script which populates #whale -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="script.js"></script>

    <!-- Enhancer script: improved neon injection + bubble spawner with parallax + caustics subtle sync -->
    <script>
      (function () {
        function applyNeon() {
          var container = document.getElementById('whale');
          if (!container) return;
          var svg = container.querySelector('svg');
          if (!svg) return;

          // Add neon filter into defs (create if missing)
          var defs = svg.querySelector('defs');
          if (!defs) {
            defs = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'defs'
            );
            svg.insertBefore(defs, svg.firstChild);
          }
          if (!svg.querySelector('#neonGlow')) {
            var frag = document.createElement('div');
            frag.innerHTML =
              '<filter id="neonGlow" x="-80%" y="-80%" width="260%" height="260%">' +
              '<feGaussianBlur stdDeviation="12" result="blur"/>' +
              '<feMerge>' +
              '  <feMergeNode in="blur"/>' +
              '  <feMergeNode in="SourceGraphic"/>' +
              '</feMerge>' +
              '<feColorMatrix type="matrix" values="1 0 0 0 0  0 0.9 0 0 0  0 0 1 0 0  0 0 0 1 0" />' +
              '</filter>';
            defs.insertBefore(frag.firstChild, defs.firstChild);
          }

          // wrap svg children (except defs) inside a group that uses the filter
          if (!svg.querySelector('g[data-neon-wrap]')) {
            var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('filter', 'url(#neonGlow)');
            g.setAttribute('data-neon-wrap', '1');
            g.setAttribute('opacity', '0.6');

            // move nodes
            var nodes = [];
            Array.from(svg.childNodes).forEach(function (n) {
              if (n.nodeName !== 'defs') nodes.push(n);
            });
            nodes.forEach(function (n) {
              g.appendChild(n);
            });
            svg.appendChild(g);
          }

          // final svg style tweaks for neon look
          svg.style.opacity = '0.96';
          svg.style.transition =
            'filter 200ms ease, opacity 200ms ease, transform 120ms linear';
          svg.style.filter =
            'drop-shadow(0 0 14px rgba(0,210,255,0.95)) drop-shadow(0 0 34px rgba(0,140,255,0.5))';
          svg.style.mixBlendMode = 'screen';
        }

        // Try applying neon repeatedly until the script.js draws the svg
        var attempts = 0;
        var t = setInterval(function () {
          attempts++;
          applyNeon();
          if (attempts > 60) clearInterval(t);
        }, 150);

        // Bubbles: spawn with parallax (some rise slowly far away, others faster near)
        function spawnBubbles(n) {
          for (var i = 0; i < n; i++) {
            var b = document.createElement('div');
            b.className = 'bubble';
            // size: more variety
            var size = Math.round(4 + Math.random() * 22);
            b.style.width = size + 'px';
            b.style.height = size + 'px';
            // horizontal spread
            b.style.left = Math.random() * 100 + 'vw';
            // start lower than viewport for natural rise
            b.style.bottom = -10 - Math.random() * 50 + 'vh';
            // vertical duration depends on size (smaller = slower far bubbles)
            var duration = (6 + Math.random() * 10) * (1 + size / 30);
            b.style.transition = 'transform linear';
            b.style.animationName = 'bubbleRise';
            b.style.animationDuration = duration + 's';
            b.style.animationTimingFunction = 'cubic-bezier(.2,.8,.2,1)';
            b.style.animationDelay = Math.random() * 4 + 's';
            b.style.opacity = 0.4 + Math.random() * 0.6;

            // optional horizontal drift implemented with transform animation via keyframes injected below
            b.style.willChange = 'transform, opacity';
            document.body.appendChild(b);
          }
        }

        // Create CSS keyframes for bubble rise dynamically (to allow variable end positions)
        var styleTag = document.createElement('style');
        styleTag.innerHTML = `
      @keyframes bubbleRise {
        0% { transform: translateY(0) translateX(0) scale(0.6); opacity:0; }
        10% { opacity:0.45; }
        100% { transform: translateY(-120vh) translateX(30px) scale(1.05); opacity:0; }
      }
    `;
        document.head.appendChild(styleTag);

        // spawn initially, then periodically add few
        document.addEventListener('DOMContentLoaded', function () {
          spawnBubbles(36);
          setInterval(function () {
            spawnBubbles(4);
          }, 4500);
        });

        // subtle sync between svg turbulence and caustics opacity to feel alive
        (function syncCaustics() {
          var svg = document.getElementById('causticsSVG');
          if (!svg) return;
          var turb = svg.querySelector('feTurbulence');
          var rect = svg.querySelector('rect');
          var t = 0;
          setInterval(function () {
            t += 0.01;
            if (turb)
              turb.setAttribute(
                'baseFrequency',
                (0.6 + Math.sin(t) * 0.08).toFixed(3)
              );
            if (rect)
              rect.style.opacity = (0.12 + Math.abs(Math.sin(t)) / 12).toFixed(
                3
              );
          }, 120);
        })();
      })();
    </script>
  </body>
</html>
